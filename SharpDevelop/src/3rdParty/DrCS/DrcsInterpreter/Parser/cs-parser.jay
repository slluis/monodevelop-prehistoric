%{
using System.Text;
using System;

namespace Rice.Drcsharp.Parser
{
	using System.Collections;
	using Rice.Drcsharp.Parser.AST;
	using Rice.Drcsharp.Parser.AST.Expressions;
	using Rice.Drcsharp.Parser.AST.Statements;
	using Rice.Drcsharp.Parser.AST.Visitors;

	/// <summary>
	///    The C# Parser
	/// </summary>
	public class CSharpParser {

		Stack oob_stack;
		string name;
		System.IO.TextReader input;
		bool yacc_verbose_flag = false;
		public ASTNode retVal;
		public bool retUsingDirective = false;
		public bool retStatement = false;
		public bool retExpression = false;
%}

%token EOF
%token NONE   /* This token is never returned by our lexer */
%token ERROR		// This is used not by the parser, but by the tokenizer.
			// do not remove.

/*
 *These are the C# keywords
 */
%token ABSTRACT	
%token AS
%token ADD
%token ASSEMBLY
%token BASE	
%token BOOL	
%token BREAK	
%token BYTE	
%token CASE	
%token CATCH	
%token CHAR	
%token CHECKED	
%token CLASS	
%token CONST	
%token CONTINUE	
%token DECIMAL	
%token DEFAULT	
%token DELEGATE	
%token DO	
%token DOUBLE	
%token ELSE	
%token ENUM	
%token EVENT	
%token EXPLICIT	
%token EXTERN	
%token FALSE	
%token FINALLY	
%token FIXED	
%token FLOAT	
%token FOR	
%token FOREACH	
%token GOTO	
%token IF	
%token IMPLICIT	
%token IN	
%token INT	
%token INTERFACE
%token INTERNAL	
%token IS	
%token LOCK	
%token LONG	
%token NAMESPACE
%token NEW	
%token NULL	
%token OBJECT	
%token OPERATOR	
%token OUT	
%token OVERRIDE	
%token PARAMS	
%token PRIVATE	
%token PROTECTED
%token PUBLIC	
%token READONLY	
%token REF	
%token RETURN	
%token REMOVE
%token SBYTE	
%token SEALED	
%token SHORT	
%token SIZEOF	
%token STACKALLOC
%token STATIC	
%token STRING	
%token STRUCT	
%token SWITCH	
%token THIS	
%token THROW	
%token TRUE	
%token TRY	
%token TYPEOF	
%token UINT	
%token ULONG	
%token UNCHECKED
%token UNSAFE	
%token USHORT	
%token USING	
%token VIRTUAL	
%token VOID	
%token VOLATILE
%token WHILE	

/* C# keywords which are not really keywords */
%token GET           "get"
%token SET           "set"

/* C# single character operators/punctuation. */
%token OPEN_BRACE    "{"
%token CLOSE_BRACE   "}"
%token OPEN_BRACKET  "["
%token CLOSE_BRACKET "]"
%token OPEN_PARENS   "("
%token CLOSE_PARENS  ")"
%token DOT           "."
%token COMMA         ","
%token COLON         ":"
%token SEMICOLON     ";"
%token TILDE         "~"

%token PLUS           "+"
%token MINUS          "-"
%token BANG           "!"
%token ASSIGN         "="
%token OP_LT          "<"
%token OP_GT          ">"
%token BITWISE_AND    "&"
%token BITWISE_OR     "|"
%token STAR           "*"
%token PERCENT        "%"
%token DIV            "/"
%token CARRET         "^"
%token INTERR         "?"

/* C# multi-character operators. */
%token OP_INC                 "++"
%token OP_DEC                 "--"
%token OP_SHIFT_LEFT          "<<"
%token OP_SHIFT_RIGHT         ">>"
%token OP_LE                  "<="
%token OP_GE                  ">="
%token OP_EQ                  "=="
%token OP_NE                  "!="
%token OP_AND                 "&&"
%token OP_OR                  "||"
%token OP_MULT_ASSIGN         "*="
%token OP_DIV_ASSIGN          "/="
%token OP_MOD_ASSIGN          "%="
%token OP_ADD_ASSIGN          "+="
%token OP_SUB_ASSIGN          "-="
%token OP_SHIFT_LEFT_ASSIGN   "<<="
%token OP_SHIFT_RIGHT_ASSIGN  ">>="
%token OP_AND_ASSIGN          "&="
%token OP_XOR_ASSIGN          "^="
%token OP_OR_ASSIGN           "|="
%token OP_PTR                 "->"

/* Numbers */
%token LITERAL_INTEGER           "int literal"
%token LITERAL_FLOAT             "float literal"
%token LITERAL_DOUBLE            "double literal"
%token LITERAL_DECIMAL           "decimal literal"
%token LITERAL_CHARACTER         "character literal"
%token LITERAL_STRING            "string literal"

%token IDENTIFIER

/* Add precedence rules to solve dangling else s/r conflict */
%nonassoc LOWPREC
%nonassoc IF
%nonassoc ELSE
%right ASSIGN
%left OP_OR
%left OP_AND
%left BITWISE_OR
%left BITWISE_AND
%left OP_SHIFT_LEFT OP_SHIFT_RIGHT
%left PLUS MINUS
%left STAR DIV PERCENT
%right BANG CARRET UMINUS
%nonassoc OP_INC OP_DEC
%left OPEN_PARENS
%left OPEN_BRACKET OPEN_BRACE
%left DOT
%nonassoc HIGHPREC

%start compilation_unit
%%

compilation_unit
        : opt_using_directive opt_EOF 
        { 
          if($1 != null) {
			retUsingDirective = true; 
		  }
		  retVal = (ASTNode)$1; 
		  DB.parsep("parsed a using directive");
		}
        | opt_statement opt_EOF 
        { 
          if($1 != null) {
			retStatement = true;
		  }
		  retVal = (ASTNode)$1; 
		  DB.parsep("parsed a statement");
		  
        }
        | expression opt_EOF
        {
          if($1 != null) {
			retExpression = true;
		  }
		  retVal = (ASTNode)$1;
		  DB.parsep("parsed a expression");
        }
//        | primary_expression opt_semicolon opt_EOF
//       {
//          if($1 != null) {
//			retExpression = true;
//			}
//		  retVal = (ASTNode)$1;
//			
//		}
        ;
        
opt_statement
	: /* empty */ {$$ = null;}
	| statement { $$ = $1; }
	;   
	
opt_EOF
	: /* empty */
	| EOF
	;

opt_using_directive
	: /* empty */ { $$ = null; }
	| using_directive { $$ = $1; }
	;
  
using_directive
	: using_alias_directive { $$ = $1; }
	| using_namespace_directive { $$ = $1; }
	;

using_alias_directive
	: USING IDENTIFIER ASSIGN 
	  namespace_or_type_name SEMICOLON
	  {
		  //current_namespace.UsingAlias ((string) $2, (string) $4, lexer.Location);
		$$ = new UsingAlias((string) $2, (string) $4, lexer.Location);
	  }
	;

using_namespace_directive
	: USING namespace_name SEMICOLON 
	{
		//current_namespace.Using ((string) $2);
		$$ = new UsingNamespace((string) $2, lexer.Location);
    }
	;

opt_semicolon
	: /* empty */
	| SEMICOLON
	;

opt_comma
	: /* empty */
	| COMMA
	;
/*
qualified_identifier
	: IDENTIFIER
	| qualified_identifier DOT IDENTIFIER { 
	    $$ = (($1).ToString ()) + "." + ($3.ToString ()); }
	;
*/
type_name
	: namespace_or_type_name { $$ = $1; }
	;

namespace_name
	: namespace_or_type_name { $$ = $1; }
	;

namespace_or_type_name
	: IDENTIFIER { $$ = $1; }
	| namespace_or_type_name DOT IDENTIFIER { 
	    $$ = (($1).ToString ()) + "." + ($3.ToString ()); }
	;
//: qualified_identifier
//	;

//opt_using_directives
//	: /* empty */
//	| using_directives
//	;



/* 
 * Before you think of adding a return_type, notice that we have been
 * using two rules in the places where it matters (one rule using type
 * and another identical one that uses VOID as the return type).  This
 * gets rid of a shift/reduce couple
 */
type
	: type_name {  	/* class_type */
		/* 
	           This does interfaces, delegates, struct_types, class_types, 
	           parent classes, and more! 4.2 
	         */
		$$ = $1; 
	  }
	| builtin_types { $$ = $1; }
	| array_type { $$ = $1; }
//	| pointer_type	 { $$ = $1; }  
	;

/*
 * replaces all the productions for isolating the various
 * simple types, but we need this to reuse it easily in local_variable_type
 */
builtin_types
	: OBJECT	{ $$ = "System.Object"; }
	| STRING	{ $$ = "System.String"; }
	| BOOL		{ $$ = "System.Boolean"; }
	| DECIMAL	{ $$ = "System.Decimal"; }
	| FLOAT		{ $$ = "System.Single"; }
	| DOUBLE	{ $$ = "System.Double"; }
	| VOID		{ $$ = "System.Void"; }
	| integral_type { $$ = $1; }
	;

integral_type
	: SBYTE		{ $$ = "System.SByte"; }
	| BYTE		{ $$ = "System.Byte"; }
	| SHORT		{ $$ = "System.Int16"; }
	| USHORT	{ $$ = "System.UInt16"; }
	| INT		{ $$ = "System.Int32"; }
	| UINT		{ $$ = "System.UInt32"; }
	| LONG		{ $$ = "System.Int64"; }
	| ULONG		{ $$ = "System.UInt64"; }
	| CHAR		{ $$ = "System.Char"; }
	;

array_type
	: type rank_specifiers
	  {
		  $$ = (string) $1 + (string) $2;
	  }
	;

//
// Expressions, section 7.5
//
primary_expression
	: literal
	  {
		// 7.5.1: Literals
		 $$ = $1;
	  } 
/*	| namespace_or_type_name
	  {
		string name = (string) $1;

		$$ = DecomposeQI (name, lexer.Location); //CHECK
	  }
*/
	| IDENTIFIER
	  {
		$$ = new SimpleName((string) $1, lexer.Location);
	  }
	| parenthesized_expression { $$ = $1; }
	| member_access { $$ = $1; }
	| invocation_expression { $$ = $1; }
	| element_access { $$ = $1; }
//	| this_access
//	| base_access
	| post_increment_expression { $$ = $1; }
	| post_decrement_expression { $$ = $1; }
	| new_expression { $$ = $1; }
//	| typeof_expression
//	| sizeof_expression
	| checked_expression { $$ = $1; }
	| unchecked_expression { $$ = $1; }
	| pointer_member_access { $$ = $1; }
	;

literal
	: boolean_literal { $$ = $1; }
	| integer_literal  { $$ = $1; }
	| real_literal { $$ = $1; }
	| LITERAL_CHARACTER     { $$ = new CharLit ((char) lexer.Value); }
	| LITERAL_STRING        { $$ = new StringLit ((string) lexer.Value, lexer.Location); }
	| NULL			{ $$ = NullLit.Instance; }
	;

boolean_literal
	: TRUE			{ $$ = BoolLit.TrueInstance; }
	| FALSE			{ $$ = BoolLit.FalseInstance; }
	;

integer_literal
	: LITERAL_INTEGER
	{ 
		object v = lexer.Value;

		// 
		// FIXME: Possible optimization would be to 
		// compute the *Literal objects directly in the scanner
		//
		if (v is int)
			$$ = new IntLit ((Int32) v); 
		else if (v is uint)
			$$ = new UIntLit ((UInt32) v);
		else if (v is long)
			$$ = new LongLit ((Int64) v);
		else if (v is ulong)
			$$ = new ULongLit ((UInt64) v);
		else
			Console.WriteLine ("OOPS.  Unexpected integer literal from scanner"); //CHECK
	  }
	;

real_literal
	: LITERAL_FLOAT         { $$ = new FloatLit ((float) lexer.Value); }
	| LITERAL_DOUBLE        { $$ = new DoubleLit ((double) lexer.Value); }
	| LITERAL_DECIMAL       { $$ = new DecimalLit ((decimal) lexer.Value); }
	;

parenthesized_expression
	: OPEN_PARENS expression CLOSE_PARENS
	  { $$ = new ParenExpr((Expression)$2, lexer.Location); }
	;

member_access
	: primary_expression DOT IDENTIFIER
	  {
		$$ = new MemberAccess ((Expression) $1, (string) $3, lexer.Location);
	  }
	| predefined_type DOT IDENTIFIER
	  {
		$$ = new MemberAccess (new SimpleName ((string) $1, lexer.Location), (string) $3, lexer.Location);
	  }
	;

predefined_type
	: builtin_types { $$ = $1; }
	; 

invocation_expression
	: primary_expression OPEN_PARENS opt_argument_list CLOSE_PARENS
	  {
		if ($1 == null) {
			Location l = lexer.Location;
			Report.Error ("messed up invocation without primary-expression", l);
		}
		$$ = new Invocation ((Expression) $1, (ArrayList) $3, lexer.Location);
	  }
	; 

opt_argument_list
	: /* empty */		{ $$ = null; }
	| argument_list { $$ = $1; }
	;

argument_list
	: argument		
	  { 
		ArrayList list = new ArrayList ();
		list.Add ($1);
		$$ = list;
	  }
	| argument_list COMMA argument
	  {
		ArrayList list = (ArrayList) $1;
		list.Add ($3);
		$$ = list;
	  }
	;

argument
	: expression
	  {
		$$ = new Argument ((Expression) $1, Argument.ArgType.Expression);
	  }
	| REF variable_reference 
	  { 
		$$ = new Argument ((Expression) $2, Argument.ArgType.Ref);
	  }
	| OUT variable_reference 
	  { 
		$$ = new Argument ((Expression) $2, Argument.ArgType.Out);
	  }
	;

variable_reference
	: expression { $$ = $1; }
	;

element_access
	: primary_expression OPEN_BRACKET expression_list CLOSE_BRACKET	
	  {
		$$ = new ElementAccess ((Expression) $1, (ArrayList) $3, lexer.Location);
	  }
/*
	| primary_expression rank_specifiers
	  {
		// So the super-trick is that primary_expression
		// can only be either a SimpleName or a MemberAccess. 
		// The MemberAccess case arises when you have a fully qualified type-name like :
		// Foo.Bar.Blah i;
		// SimpleName is when you have
		// Blah i;
		  
		Expression expr = (Expression) $1;  
		if (!(expr is SimpleName || expr is MemberAccess)) {
			Location l = lexer.Location;
			Report.Error ("Invalid Type definition", l);
			$$ = "System.Object";
		}
		
		//
		// So we extract the string corresponding to the SimpleName
		// or MemberAccess
		// 
		$$ = new SimpleName (GetQualifiedIdentifier (expr) + (string) $2, lexer.Location); //CHECK
	  }
*/
	;

expression_list
	: expression
	  {
		ArrayList list = new ArrayList ();
		list.Add ($1);
		$$ = list;
	  }
	| expression_list COMMA expression
	  {
		ArrayList list = (ArrayList) $1;
		list.Add ($3);
		$$ = list;
	  }
	;

this_access
	: THIS
	  {
		$$ = new This (lexer.Location);
	  }
	;

base_access
	: BASE DOT IDENTIFIER
	  {
		$$ = new BaseAccess ((string) $3, lexer.Location);
	  }
	| BASE OPEN_BRACKET expression_list CLOSE_BRACKET
	  {
		$$ = new BaseIndexerAccess ((ArrayList) $3, lexer.Location);
	  }
	;

post_increment_expression
	: primary_expression OP_INC
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PostIncrement,
				       (Expression) $1, lexer.Location);
	  }
	;

post_decrement_expression
	: primary_expression OP_DEC
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PostDecrement,
				       (Expression) $1, lexer.Location);
	  }
	;

new_expression
	: object_or_delegate_creation_expression
	| array_creation_expression
	;

object_or_delegate_creation_expression
	: NEW type OPEN_PARENS opt_argument_list CLOSE_PARENS
	{
		$$ = new New (new CType((string) $2), (ArrayList) $4, lexer.Location);
	}
	;

array_creation_expression
	: NEW type OPEN_BRACKET expression_list CLOSE_BRACKET 
	  opt_rank_specifier
	  opt_array_initializer
	  {
		$$ = new ArrayCreation (new CType((string) $2), (ArrayList) $4, (string) $6, (ArrayList) $7, 
					lexer.Location);
	  }
	| NEW type rank_specifiers array_initializer
	  {
		$$ = new ArrayCreation (new CType((string) $2), (string) $3, (ArrayList) $4, lexer.Location);
	  }
	| NEW type error 
	  {
		Report.Error ("new expression requires () or [] after type", lexer.Location);
	  }
	;

opt_rank_specifier
	: /* empty */
	  {
		$$ = "";
	  }
	| rank_specifiers
	  {
		$$ = $1;
	  }
	;

rank_specifiers
	: rank_specifier
	  {
		  $$ = $1;
	  }
	| rank_specifiers rank_specifier
	  {
		  $$ = (string) $1 + (string) $2;
	  }     	
        ;

rank_specifier
	: OPEN_BRACKET opt_dim_separators CLOSE_BRACKET
	  {
		$$ = "[" + (string) $2 + "]";
	  }
	;

opt_dim_separators
	: /* empty */
	  {
		$$ = "";
	  }
	| dim_separators
	  {
		  $$ = $1;
	  }		  
	;

dim_separators
	: COMMA
	  {
		$$ = ",";
	  }
	| dim_separators COMMA
	  {
		$$ = (string) $1 + ",";
	  }
	;

opt_array_initializer
	: /* empty */
	  {
		$$ = null;
	  }
        | array_initializer
	  {
		$$ = $1;
	  }
	;

array_initializer
	: OPEN_BRACE CLOSE_BRACE
	  {
		ArrayList list = new ArrayList ();
		$$ = list;
	  }
	| OPEN_BRACE variable_initializer_list opt_comma CLOSE_BRACE
	  {
		$$ = (ArrayList) $2;
	  }
	;

variable_initializer_list
	: variable_initializer
	  {
		ArrayList list = new ArrayList ();
		list.Add ($1);
		$$ = list;
	  }
	| variable_initializer_list COMMA variable_initializer
	  {
		ArrayList list = (ArrayList) $1;
		list.Add ($3);
		$$ = list;
	  }
	;

typeof_expression
	: TYPEOF OPEN_PARENS type CLOSE_PARENS
	  {
		$$ = new TypeOf (new CType((string) $3), lexer.Location);
	  }
	;

sizeof_expression
	: SIZEOF OPEN_PARENS type CLOSE_PARENS { 
		$$ = new SizeOf (new CType((string) $3), lexer.Location); //CHECK

//		note ("Verify type is unmanaged"); 
//		note ("if (5.8) builtin, yield constant expression");
	  }
	;

checked_expression
	: CHECKED OPEN_PARENS expression CLOSE_PARENS
	  {
		$$ = new CheckedExpression ((Expression) $3, lexer.Location);
	  }
	;

unchecked_expression
	: UNCHECKED OPEN_PARENS expression CLOSE_PARENS
	  {
		$$ = new UncheckedExpression ((Expression) $3, lexer.Location);
	  }
	;

pointer_member_access 
	: primary_expression OP_PTR IDENTIFIER
	  {
		$$ = new Unary (Unary.UnaryOperator.Indirection, (Expression) $1, lexer.Location);
		//$$ = new MemberAccess (deref, (string) $3, lexer.Location);
	  }

non_expression_type
	: builtin_types	
	  {
		$$ = new SimpleName ((string) $1, lexer.Location);
	  }
	| non_expression_type rank_specifier
	  {
		$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
	  }
//	| non_expression_type STAR
//	  {
//		$$ = new ComposedCast ((Expression) $1, "*", lexer.Location);
//	  }
	| expression rank_specifiers 
	  {
		$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
	  }
//	| expression STAR 
//	  {
//		$$ = new ComposedCast ((Expression) $1, "*", lexer.Location);
//	  }
	;


unary_expression
	: primary_expression { $$ = $1; }
	| BANG prefixed_unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.LogicalNot, (Expression) $2, lexer.Location);
	  }
	| TILDE prefixed_unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.OnesComplement, (Expression) $2, lexer.Location);
	  }
        | OPEN_PARENS expression CLOSE_PARENS unary_expression //CHECK could use expression instead of type
	  {
		  $$ = new ClassCast((Expression)$4, (Expression) $2, lexer.Location);
	  }
        | OPEN_PARENS non_expression_type CLOSE_PARENS prefixed_unary_expression
	  {
		  $$ = new ClassCast((Expression)$4, (Expression) $2, lexer.Location);
	  }
	;

	//
	// The idea to split this out is from Rhys' grammar
	// to solve the problem with casts.
	//
prefixed_unary_expression
	: unary_expression { $$ = $1; }
	| PLUS prefixed_unary_expression
	  { 
	  	$$ = new Unary (Unary.UnaryOperator.UnaryPlus, (Expression) $2, lexer.Location);
	  } 
	| MINUS prefixed_unary_expression 
	  { 
		$$ = new Unary (Unary.UnaryOperator.UnaryNegation, (Expression) $2, lexer.Location);
	  }
	| OP_INC prefixed_unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreIncrement, (Expression) $2, lexer.Location);
	  }
	| OP_DEC prefixed_unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreDecrement, (Expression) $2, lexer.Location);
	  }
	| STAR prefixed_unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.Indirection, (Expression) $2, lexer.Location);
	  }
	| BITWISE_AND prefixed_unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.AddressOf, (Expression) $2, lexer.Location);
	  }
	;

/*
unary_expression
	: primary_expression
	| BANG unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.LogicalNot, (Expression) $2, lexer.Location);
	  }
	| TILDE unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.OnesComplement, (Expression) $2, lexer.Location);
	  }
	| PLUS unary_expression
	  { 
	  	$$ = new Unary (Unary.UnaryOperator.UnaryPlus, (Expression) $2, lexer.Location);
	  } 
	| MINUS unary_expression 
	  { 
		$$ = new Unary (Unary.UnaryOperator.UnaryNegation, (Expression) $2, lexer.Location);
	  }
	| OP_INC unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreIncrement, (Expression) $2, lexer.Location);
	  }
	| OP_DEC unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreDecrement, (Expression) $2, lexer.Location);
	  }
	| STAR unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.Indirection, (Expression) $2, lexer.Location);
	  }
	| BITWISE_AND unary_expression
	  {
		$$ = new Unary (Unary.UnaryOperator.AddressOf, (Expression) $2, lexer.Location);
	  }
	;
        | OPEN_PARENS type CLOSE_PARENS unary_expression //CHECK could use expression instead of type
	  {
		  $$ = new ClassCast((Expression) $4, new CType((string)$2), lexer.Location);
	  }
 	;
*/

pre_increment_expression
	: OP_INC prefixed_unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreIncrement, (Expression) $2, lexer.Location);
	  }
	;

pre_decrement_expression
	: OP_DEC prefixed_unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreDecrement, (Expression) $2, lexer.Location);
	  }
	;

/*
pre_increment_expression
	: OP_INC unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreIncrement, (Expression) $2, lexer.Location);
	  }
	;

pre_decrement_expression
	: OP_DEC unary_expression 
	  {
		$$ = new UnaryMutator (UnaryMutator.UMode.PreDecrement, (Expression) $2, lexer.Location);
	  }
	;
*/

multiplicative_expression
	: prefixed_unary_expression { $$ = $1; }
	| multiplicative_expression STAR prefixed_unary_expression
	  {
		$$ = new Binary (Binary.BiOperator.Multiply, 
			         (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| multiplicative_expression DIV prefixed_unary_expression
	  {
		$$ = new Binary (Binary.BiOperator.Division, 
			         (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| multiplicative_expression PERCENT prefixed_unary_expression 
	  {
		$$ = new Binary (Binary.BiOperator.Modulus, 
			         (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

/*
multiplicative_expression
	: unary_expression
	| multiplicative_expression STAR unary_expression
	  {
		$$ = new Binary (Binary.BiOperator.Multiply, 
			         (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| multiplicative_expression DIV unary_expression
	  {
		$$ = new Binary (Binary.BiOperator.Division, 
			         (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| multiplicative_expression PERCENT unary_expression 
	  {
		$$ = new Binary (Binary.BiOperator.Modulus, 
			         (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;
*/

additive_expression
	: multiplicative_expression { $$ = $1; }
	| additive_expression PLUS multiplicative_expression 
	  {
		$$ = new Binary (Binary.BiOperator.Addition, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| additive_expression MINUS multiplicative_expression
	  {
		$$ = new Binary (Binary.BiOperator.Subtraction, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

shift_expression
	: additive_expression { $$ = $1; }
	| shift_expression OP_SHIFT_LEFT additive_expression
	  {
		$$ = new Binary (Binary.BiOperator.LeftShift, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| shift_expression OP_SHIFT_RIGHT additive_expression
	  {
		$$ = new Binary (Binary.BiOperator.RightShift, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	; 

relational_expression
	: shift_expression { $$ = $1; }
	| relational_expression OP_LT shift_expression
	  {
		$$ = new Binary (Binary.BiOperator.LessThan, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| relational_expression OP_GT shift_expression
	  {
		$$ = new Binary (Binary.BiOperator.GreaterThan, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| relational_expression OP_LE shift_expression
	  {
		$$ = new Binary (Binary.BiOperator.LessThanOrEqual, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| relational_expression OP_GE shift_expression
	  {
		$$ = new Binary (Binary.BiOperator.GreaterThanOrEqual, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| relational_expression IS type
	  {
		$$ = new Is ((Expression) $1, new CType((string) $3), lexer.Location);
	  }
	| relational_expression AS type
	  {
		$$ = new As ((Expression) $1, new CType((string) $3), lexer.Location);
	  }
	;

equality_expression
	: relational_expression { $$ = $1; }
	| equality_expression OP_EQ relational_expression
	  {
		$$ = new Binary (Binary.BiOperator.Equality, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	| equality_expression OP_NE relational_expression
	  {
		$$ = new Binary (Binary.BiOperator.Inequality, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	; 

and_expression
	: equality_expression { $$ = $1; }
	| and_expression BITWISE_AND equality_expression
	  {
		$$ = new Binary (Binary.BiOperator.BitwiseAnd, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

exclusive_or_expression
	: and_expression { $$ = $1; }
	| exclusive_or_expression CARRET and_expression
	  {
		$$ = new Binary (Binary.BiOperator.ExclusiveOr, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

inclusive_or_expression
	: exclusive_or_expression { $$ = $1; }
	| inclusive_or_expression BITWISE_OR exclusive_or_expression
	  {
		$$ = new Binary (Binary.BiOperator.BitwiseOr, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

conditional_and_expression
	: inclusive_or_expression { $$ = $1; }
	| conditional_and_expression OP_AND inclusive_or_expression
	  {
		$$ = new Binary (Binary.BiOperator.LogicalAnd, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

conditional_or_expression 
	: conditional_and_expression { $$ = $1; }
	| conditional_or_expression OP_OR conditional_and_expression
	  {
		$$ = new Binary (Binary.BiOperator.LogicalOr, (Expression) $1, (Expression) $3, lexer.Location);
	  }
	;

conditional_expression
	: conditional_or_expression { $$ = $1; }
	| conditional_or_expression INTERR expression COLON expression 
	  {
		$$ = new Conditional ((Expression) $1, (Expression) $3, (Expression) $5, lexer.Location);
	  }
	;

assignment_expression
	: prefixed_unary_expression ASSIGN expression
	  {
		$$ = new Assignment ((Expression) $1, (Expression) $3, lexer.Location);
	  }
	| prefixed_unary_expression OP_MULT_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Multiply, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_DIV_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Division, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_MOD_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Modulus, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_ADD_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Addition, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_SUB_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Subtraction, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.LeftShift, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.RightShift, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_AND_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.BitwiseAnd, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_OR_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.BitwiseOr, (Expression) $1, (Expression) $3, l);
	  }
	| prefixed_unary_expression OP_XOR_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.ExclusiveOr, (Expression) $1, (Expression) $3, l);
	  }
	;
/*
assignment_expression
	: unary_expression ASSIGN expression
	  {
		$$ = new Assignment ((Expression) $1, (Expression) $3, lexer.Location);
	  }
	| unary_expression OP_MULT_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Multiply, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_DIV_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Division, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_MOD_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Modulus, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_ADD_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Addition, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_SUB_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.Subtraction, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_SHIFT_LEFT_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.LeftShift, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_SHIFT_RIGHT_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.RightShift, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_AND_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.BitwiseAnd, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_OR_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.BitwiseOr, (Expression) $1, (Expression) $3, l);
	  }
	| unary_expression OP_XOR_ASSIGN expression
	  {
		Location l = lexer.Location;
		$$ = new CompoundAssignment (Binary.BiOperator.ExclusiveOr, (Expression) $1, (Expression) $3, l);
	  }
	;
*/
expression
	: conditional_expression { $$ = $1; }
	| assignment_expression { $$ = $1; }
	;

constant_expression
	: expression { $$ = $1; }
	;

boolean_expression
	: expression { $$ = $1; }
	;


// Statements (8.2)
//

opt_statement_list
	: /* empty */ { $$ = null; }
	| statement_list  { $$ = $1; }
	;

statement_list
	: statement
	{
		ArrayList stl = new ArrayList ();
		stl.Add ($1);
		$$ = stl;
	}
	| statement_list statement
	{
		ArrayList stl = (ArrayList) $1;
		stl.Add ($2);
		$$ = stl;
    }
	;

statement
	: declaration_statement { $$ = $1; }
	| labeled_statement { $$ = $1; }
	| embedded_statement { $$ = $1; }
	;


declaration_statement
	: local_variable_declaration SEMICOLON { $$ = $1; }
	| local_constant_declaration SEMICOLON { $$ = $1; }
	;



/* 
 * The following is from Rhys' grammar:
 * > Types in local variable declarations must be recognized as 
 * > expressions to prevent reduce/reduce errors in the grammar.
 * > The expressions are converted into types during semantic analysis.
 */
local_variable_type
	: primary_expression opt_rank_specifier
	  { 
		// FIXME: Do something smart here regarding the composition of the type.

		// Ok, the above "primary_expression" is there to get rid of
		// both reduce/reduce and shift/reduces in the grammar, it should
		// really just be "type_name".  If you use type_name, a reduce/reduce
		// creeps up.  If you use qualified_identifier (which is all we need
		// really) two shift/reduces appear.
		// 

		// So the super-trick is that primary_expression
		// can only be either a SimpleName or a MemberAccess. 
		// The MemberAccess case arises when you have a fully qualified type-name like :
		// Foo.Bar.Blah i;
		// SimpleName is when you have
		// Blah i;
		  
		Expression expr = (Expression) $1;  
		if (!(expr is SimpleName || expr is MemberAccess)) {
			Report.Error("Invalid Type definition", lexer.Location);
			$$ = "System.Object";
		}
		
		//
		// So we extract the string corresponding to the SimpleName
		// or MemberAccess
		// 
		//Console.WriteLine("local_variable_type: primary_expression"); 
		$$ = GetQualifiedIdentifier (expr) + (string) $2;
	  }
	| builtin_types opt_rank_specifier
	  {
		//Console.WriteLine("<local_variable_type>" + (string) $1 + (string) $2);
		
		$$ = (string) $1 + (string) $2;
	  }
        ;

local_variable_declaration
	: local_variable_type variable_declarators
	  {
	  /*
	  Console.WriteLine("<local_variable_declaration>");
	  Console.WriteLine("type = " + $1);
	  ArrayList al = (ArrayList)$2;
	  for(int i = 0; i < al.Count; i++) {
	   Console.WriteLine("in loop");
		VariableDeclaration vd = (VariableDeclaration)al[i];
		Console.WriteLine("in loop 2");
		testPrint(10);
		Console.WriteLine("vd.Ident = " + vd.Ident);
		Console.WriteLine("in loop 3");
	  }
	  Console.WriteLine("got here");
	  Console.WriteLine("</local_variable_declaration>");
	  */
	  $$ = new LocalVarDecl(new CType((string) $1), (ArrayList)$2, lexer.Location);
	  }
 	;

local_constant_declaration
	: CONST local_variable_type constant_declarators
	  {
		$$ = new LocalConstDecl(new CType((string) $2), (ArrayList)$3, lexer.Location);
	  }
	;

constant_declarators
	: constant_declarator 
	  {
		ArrayList decl = new ArrayList ();
		decl.Add ($1);
		$$ = decl;
	  }
	| constant_declarators COMMA constant_declarator
	  {
		ArrayList decls = (ArrayList) $1;
		decls.Add ($3);
		$$ = decls;
	  }
	;
	
constant_declarator
	: IDENTIFIER ASSIGN constant_expression
	  {
		$$ = new VariableDeclaration ((string) $1, (Expression)$3, lexer.Location);
	  }
	;

variable_declarators
	: variable_declarator 
	  {
		ArrayList decl = new ArrayList ();
		decl.Add ($1);
		$$ = decl;
	  }
	| variable_declarators COMMA variable_declarator
	  {
		ArrayList decls = (ArrayList) $1;
		decls.Add ($3);
		$$ = decls;
	  }
	;

variable_declarator
	: IDENTIFIER ASSIGN variable_initializer
	  {
		$$ = new VariableDeclaration ((string) $1, $3, lexer.Location);
	  }
	| IDENTIFIER
	  {
		$$ = new VariableDeclaration ((string) $1, null, lexer.Location);
	  }
	;

variable_initializer
	: expression
	  {
		$$ = $1;
	  }
	| array_initializer
	  {
		$$ = $1;
	  }
//	| STACKALLOC type OPEN_BRACKET expression CLOSE_BRACKET
//	  {
//		$$ = new StackAlloc (new CType((string) $2), (Expression) $4, lexer.Location);
//	  }
	;

labeled_statement
	: IDENTIFIER COLON  statement
	  {
		$$ = new LabeledStatement((string) $1, (Statement) $3, lexer.Location);
	  }
	;


embedded_statement
	: block { $$ = $1; }
	| empty_statement { $$ = $1; }
    | expression_statement { $$ = $1; }
	| selection_statement { $$ = $1; }
	| iteration_statement { $$ = $1; }
	| jump_statement { $$ = $1; }		  
	| try_statement { $$ = $1; }
	| checked_statement { $$ = $1; }
	| unchecked_statement { $$ = $1; }
	| lock_statement { $$ = $1; }
	| using_statement { $$ = $1; }
	| unsafe_statement { $$ = $1; }
//	| fixed_statement { $$ = $1; }
	;



//
// A block is "contained" on the following places:
//	method_body
//	property_declaration as part of the accessor body (get/set)
//      operator_declaration
//	constructor_declaration
//	destructor_declaration
//	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
//      
block
	: OPEN_BRACE opt_statement_list CLOSE_BRACE 
	  {
		$$ = new Block((ArrayList) $2, lexer.Location);
	  }
	;

empty_statement
	: SEMICOLON
	  {
		  $$ = EmptyStatement.Instance;
	  }
	;

expression_statement
	: statement_expression SEMICOLON
	  {
		$$ =  new ExpressionStatement((StatementExpression)$1, lexer.Location);
	  }
	;

	//
	// We have to do the wrapping here and not in the case above,
	// because statement_expression is used for example in for_statement
	//
statement_expression
	: invocation_expression		{ $$ = $1; }
	| object_creation_expression	{ $$ = $1; }
	| assignment_expression		{ $$ = $1; }
	| post_increment_expression	{ $$ = $1; }
	| post_decrement_expression	{ $$ = $1; }
	| pre_increment_expression	{ $$ = $1; }
	| pre_decrement_expression	{ $$ = $1; }
	| error { Report.Error ("Expecting ';'", lexer.Location); }
	;

object_creation_expression
	: object_or_delegate_creation_expression { $$ = $1; } //CHECK { note ("complain if this is a delegate maybe?"); } 
	;

selection_statement
	: if_statement { $$ = $1; }
	| switch_statement { $$ = $1; }
	; 

if_statement
	: if_statement_open if_statement_rest
	  {
		$$ = $2;
	  }
	;

if_statement_open
	: IF OPEN_PARENS 
	  {
	   	oob_stack.Push (lexer.Location);
	  }
	;

if_statement_rest
	: boolean_expression CLOSE_PARENS embedded_statement
	  { 
		Location l = (Location) oob_stack.Pop ();
		$$ = new If ((Expression) $1, (Statement) $3, l);
	  }
	| boolean_expression CLOSE_PARENS embedded_statement ELSE embedded_statement
	  {
		Location l = (Location) oob_stack.Pop ();
		$$ = new If ((Expression) $1, (Statement) $3, (Statement) $5, l);
	  }
	;

switch_statement
	: SWITCH OPEN_PARENS 
	  { 
		oob_stack.Push (lexer.Location);
	  }
	  expression CLOSE_PARENS switch_block
	  {
		$$ = new Switch ((Expression) $4, (ArrayList) $6, (Location) oob_stack.Pop ());
	  }
	;

switch_block
	: OPEN_BRACE opt_switch_sections CLOSE_BRACE
	  {
		$$ = $2;
	  }
	;

opt_switch_sections
	: /* empty */ 		
    {
	  	Report.Error ("Empty switch block", lexer.Location); 
	}
	| switch_sections { $$ = $1; }
	;

switch_sections
	: switch_section 
	  {
		ArrayList sections = new ArrayList ();
		sections.Add ($1);
		$$ = sections;
	  }
	| switch_sections switch_section
	  {
		ArrayList sections = (ArrayList) $1;
		sections.Add ($2);
		$$ = sections;
	  }
	;

switch_section
	: switch_labels statement_list 
	  {
		$$ = new SwitchSection ((ArrayList) $1, (ArrayList) $2, lexer.Location);
	  }
	;

switch_labels
	: switch_label 
	  {
		ArrayList labels = new ArrayList ();
		labels.Add ($1);
		$$ = labels;
	  }
	| switch_labels switch_label 
	  {
		ArrayList labels = (ArrayList) ($1);
		labels.Add ($2);
		$$ = labels;
	  }
	;

switch_label
	: CASE constant_expression COLON 	{ $$ = new SwitchLabel ((Expression) $2, lexer.Location); }
	| DEFAULT COLON				{ $$ = new SwitchLabel (null, lexer.Location); }
//	| error { Report.Error ("The keyword case or default must precede code in switch block", lexer.Location); }
	;

iteration_statement 
	: while_statement { $$ = $1; }
	| do_statement { $$ = $1; }
	| for_statement { $$ = $1; }
	| foreach_statement { $$ = $1; }
	;

while_statement
	: WHILE OPEN_PARENS 
	{
		oob_stack.Push (lexer.Location);
	}
	boolean_expression CLOSE_PARENS embedded_statement
	{
		Location l = (Location) oob_stack.Pop ();
		$$ = new While ((Expression) $4, (Statement) $6, l);
	}
	;

do_statement
	: DO embedded_statement WHILE OPEN_PARENS boolean_expression CLOSE_PARENS SEMICOLON
	  {
		$$ = new Do ((Statement) $2, (Expression) $5, lexer.Location);
	  }
	;

for_statement
	: FOR OPEN_PARENS  opt_for_initializer SEMICOLON
	  {
		oob_stack.Push (lexer.Location);
	  } 
	  opt_for_condition SEMICOLON opt_for_iterator CLOSE_PARENS embedded_statement
	  {
		Location l = (Location) oob_stack.Pop ();
		$$ = new For ((object) $3, (Expression) $6, (ArrayList) $8, (Statement) $10, l);
	  }
	;

opt_for_initializer
	: /* empty */		{ $$ = null; }
	| for_initializer	{ $$ = $1; }
	;

for_initializer
	: local_variable_declaration { $$ = $1; }
	| statement_expression_list { $$ = $1; }
	;

opt_for_condition
	: /* empty */		{ $$ = null; }
	| boolean_expression { $$ = $1; }
	;

opt_for_iterator
	: /* empty */		{ $$ = null; }
	| for_iterator { $$ = $1; }
	;

for_iterator
	: statement_expression_list { $$ = $1; }
	;

statement_expression_list
	: statement_expression
	  {
		ArrayList sel = new ArrayList ();
		sel.Add ($1);
		$$ = sel;
	  }
	| statement_expression_list COMMA statement_expression
	  {
		ArrayList sel = (ArrayList) $1;
		sel.Add ($3);
		$$ = sel;
	  }
	;

foreach_statement
	: FOREACH OPEN_PARENS type IDENTIFIER IN 
	  {
		oob_stack.Push (lexer.Location);
	  }
	  expression CLOSE_PARENS embedded_statement 
	  {
		Location l = (Location) oob_stack.Pop ();
		Foreach f = new Foreach (new CType((string) $3), (string)$4, (Expression) $7, (Statement) $9, l);
		$$ = f;
	  }
	;

jump_statement
	: break_statement { $$ = $1; }
	| continue_statement { $$ = $1; }
	| goto_statement { $$ = $1; }
	| return_statement { $$ = $1; }
	| throw_statement { $$ = $1; }
	;

break_statement
	: BREAK SEMICOLON
	  {
		$$ = new Break (lexer.Location);
	  }
	;

continue_statement
	: CONTINUE SEMICOLON
	  {
		$$ = new Continue (lexer.Location);
	  }
	;

goto_statement
	: GOTO IDENTIFIER SEMICOLON 
	  {
		$$ = new Goto ((string) $2, lexer.Location);
	  }
	| GOTO CASE constant_expression SEMICOLON
	  {
		$$ = new Goto ((Expression) $3, lexer.Location);
	  }
	| GOTO DEFAULT SEMICOLON 
	  {
		$$ = new Goto (lexer.Location);
	  }
	; 

return_statement
	: RETURN opt_expression SEMICOLON
	  {
		$$ = new Return ((Expression) $2, lexer.Location);
	  }
	;

throw_statement
	: THROW opt_expression SEMICOLON
	  {
		$$ = new Throw ((Expression) $2, lexer.Location);
	  }
	;

opt_expression
	: /* empty */ { $$ = null; }
	| expression { $$ = $1; }
	;

try_statement
	: TRY block catch_clauses 
	{
		Catch g = null;
		ArrayList s = new ArrayList ();
		
		foreach (Catch cc in (ArrayList) $3) {
			if (cc.CatchArgs.WantedType == null)
				g = cc;
			else
				s.Add (cc);
		}

		// Now s contains the list of specific catch clauses
		// and g contains the general one.
		
		$$ = new Try ((Block) $2, s, g, null, lexer.Location);
	}
	| TRY block opt_catch_clauses FINALLY block
	  {
		Catch g = null;
		ArrayList s = new ArrayList ();
		ArrayList catch_list = (ArrayList) $3;

		if (catch_list != null) {
			foreach (Catch cc in catch_list) {
				if (cc.CatchArgs.WantedType == null) 
					g = cc;     		//CHECK - only 1 general clause and has to be last
				else
					s.Add (cc);
			}
		}
		
		$$ = new Try ((Block) $2, s, g, (Block) $5, lexer.Location);
	  }
	| TRY block error 
	  {
		Report.Error ("Expected catch or finally", lexer.Location);
	  }
	;

opt_catch_clauses
	: /* empty */  { $$ = null; }
    | catch_clauses { $$ = $1; }
	;

catch_clauses
	: catch_clause 
	  {
		ArrayList l = new ArrayList ();
		l.Add ($1);
		$$ = l;
	  }
	| catch_clauses catch_clause
	  {
		ArrayList l = (ArrayList) $1;
		l.Add ($2);
		$$ = l;
	  }
	;

opt_identifier
	: /* empty */	{ $$ = null; }
	| IDENTIFIER { $$ = $1; }
	;

catch_clause 
	: CATCH opt_catch_args block
	{
	$$ = new Catch ((CatchArgs)$2, (Block) $3, lexer.Location);
	}
    ;

opt_catch_args
	: /* empty */ { $$ = null; }
	| catch_args { $$ = $1; }
	;	  

catch_args 
	: OPEN_PARENS type opt_identifier CLOSE_PARENS 
	{
	$$ = new CatchArgs(new CType((string) $2), (string)$3, lexer.Location);
	}
	;

checked_statement
	: CHECKED block
	  {
		$$ = new CheckedStatement ((Block) $2, lexer.Location);
	  }
	;

unchecked_statement
	: UNCHECKED block
	  {
		$$ = new UncheckedStatement ((Block) $2, lexer.Location);
	  }
	;

unsafe_statement
	: UNSAFE  block
	{
		$$ = new Unsafe ((Block) $2, lexer.Location);
	}
	;
/*
fixed_statement
	: FIXED OPEN_PARENS pointer_type fixed_pointer_declarators CLOSE_PARENS 
	  {
		Location l = lexer.Location;
		oob_stack.Push (l);
	  }
	  embedded_statement 
	  {
		Location l = (Location) oob_stack.Pop ();
	
		ArrayList list = (ArrayList) $4;	
		$$ = new Fixed (new CType((string) $3), (ArrayList) $4, (Statement) $5, l);
	  }
	;

fixed_pointer_declarators
	: fixed_pointer_declarator	{ 
	   	ArrayList declarators = new ArrayList (); 
		declarators.Add ($1);
		$$ = declarators;
	  }
	| fixed_pointer_declarators COMMA fixed_pointer_declarator
	  {
		ArrayList declarators = (ArrayList) $1;
		declarators.Add ($3);
		$$ = declarators;
	  }
	;

fixed_pointer_declarator
	: IDENTIFIER ASSIGN expression
	  {	
		$$ = new FixedPtrDecl ((string)$1, (Expression)$3, lexer.Location);
	  }
	;
*/
lock_statement
	: LOCK OPEN_PARENS expression CLOSE_PARENS embedded_statement
	  {
		$$ = new Lock ((Expression) $3, (Statement) $5, lexer.Location);
	  }
	;

using_statement
	: USING OPEN_PARENS resource_acquisition CLOSE_PARENS 
	  {
		oob_stack.Push (lexer.Location);
  	  } 
	  embedded_statement
	  {
		$$ = new UsingStatement ($3, (Statement) $5, (Location) oob_stack.Pop ());
	  }
	; 

resource_acquisition
	: local_variable_declaration { $$ = $1; }
	| expression { $$ = $1; }
	;

%%

Expression DecomposeQI (string name, Location loc)
{
	Expression o;

	if (name.IndexOf ('.') == -1){
			return new SimpleName (name, loc);
	} else {
		int pos = name.LastIndexOf (".");
		string left = name.Substring (0, pos);
		string right = name.Substring (pos + 1);

		o = DecomposeQI (left, loc);
		return new MemberAccess (o, right, loc);
	}
}

// <summary>
//  This method is used to get at the complete string representation of
//  a fully-qualified type name, hiding inside a MemberAccess ;-)
//  This is necessary because local_variable_type admits primary_expression
//  as the type of the variable. So we do some extra checking
// </summary>
string GetQualifiedIdentifier (Expression expr)
{
	if (expr is SimpleName)
		return ((SimpleName)expr).Name;
	else if (expr is MemberAccess)
		return GetQualifiedIdentifier (((MemberAccess)expr).Expr) + "." + ((MemberAccess) expr).Ident;
	else 
		throw new Exception ("Expr has to be either SimpleName or MemberAccess! (" + expr + ")");
	
}

void note (string s)
{
	Console.WriteLine("NOTE:" + s ); // Used to put annotations
}

Tokenizer lexer;

public Tokenizer Lexer {
	get {
		return lexer;
	}
}		   


public CSharpParser (string name, System.IO.TextReader input)
{
	this.name = name;
	this.input = input;
	oob_stack = new Stack ();

	lexer = new Tokenizer (input, name);
}

public void Reset(System.IO.TextReader input) {
	this.input = input;
	oob_stack = new Stack();
	
	lexer.Reset(input);
}

public int parse ()
{
	//global_errors = 0;
	try {
		if (yacc_verbose_flag)
			yyparse (lexer, new yydebug.yyDebugSimple ());
		else
			yyparse (lexer);
	} catch (Exception){
		// Console.WriteLine ("Fatal error: " + name);
		// Console.WriteLine (lexer.location);

		// 
		// Please do not remove this, it is used during debugging
		// of the grammar
		//
		//Console.WriteLine (lexer.location + "  : Parsing error ");
		//Console.WriteLine (e);
		//global_errors++;
		throw;
	}
	return 0;
	//return global_errors;
}

}
